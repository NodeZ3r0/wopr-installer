"""
WOPR Billing Integration
========================

Stripe integration for WOPR Sovereign Suite and Micro-Bundle subscriptions.

Pricing Structure (January 2026):
- 7 Sovereign Suites: Starter, Creator, Developer, Professional, Family, Small Business, Enterprise
- 16 Micro-Bundles: Meeting Room, Privacy Pack, Writer's Studio, etc.
- 3 Storage Tiers: T1 (50GB), T2 (200GB), T3 (500GB+)
- Total: 69 products (23 bundles Ã— 3 tiers)

Flow:
1. User selects bundle, tier, and provider/region on join page
2. Redirect to onboarding wizard for account details
3. Create Stripe Checkout Session with metadata
4. Redirect user to Stripe payment page
5. Webhook receives payment confirmation
6. Trigger provisioning with payment metadata
7. Send welcome email with setup instructions

Documentation:
- Stripe Checkout: https://docs.stripe.com/payments/checkout
- Stripe Webhooks: https://docs.stripe.com/webhooks
- Stripe Trials: https://docs.stripe.com/billing/subscriptions/trials

Updated: January 2026
"""

import os
import json
import hmac
import hashlib
from datetime import datetime
from typing import Dict, Optional, Any, List
from dataclasses import dataclass, field
from enum import Enum

try:
    import stripe
    STRIPE_AVAILABLE = True
except ImportError:
    STRIPE_AVAILABLE = False

# Import the Stripe catalog (auto-generated by stripe-setup.ps1)
from .stripe_catalog import (
    STRIPE_PRICES,
    STRIPE_PRODUCTS,
    BUNDLE_PRICING,
    BUNDLE_INFO,
    TIER_INFO,
    get_price_id,
    get_product_id,
    get_price_cents,
    get_price_display,
    get_bundle_info,
    get_tier_info,
    get_all_bundles,
    get_sovereign_suites,
    get_micro_bundles,
    is_valid_bundle,
    is_valid_tier,
)


class StorageTier(Enum):
    """Storage tiers for WOPR bundles."""
    T1 = "t1"  # 50GB
    T2 = "t2"  # 200GB
    T3 = "t3"  # 500GB+


# Legacy enum for backwards compatibility
class SubscriptionTier(Enum):
    """WOPR subscription tiers (legacy - use bundle IDs directly)."""
    PERSONAL = "starter"  # Renamed from personal to starter
    CREATOR = "creator"
    DEVELOPER = "developer"
    PROFESSIONAL = "professional"
    FAMILY = "family"
    SMALL_BUSINESS = "small_business"
    ENTERPRISE = "enterprise"


@dataclass
class PricingPlan:
    """Pricing details for a subscription tier."""
    price_monthly_usd: float
    price_yearly_usd: float
    features: List[str]


# Pricing plans by subscription tier
PRICING_PLANS: Dict[SubscriptionTier, PricingPlan] = {
    SubscriptionTier.PERSONAL: PricingPlan(
        price_monthly_usd=15.0,
        price_yearly_usd=150.0,
        features=["5 core apps", "50GB storage", "SSO", "Email support"],
    ),
    SubscriptionTier.CREATOR: PricingPlan(
        price_monthly_usd=25.0,
        price_yearly_usd=250.0,
        features=["10 apps", "100GB storage", "SSO", "Priority support"],
    ),
    SubscriptionTier.DEVELOPER: PricingPlan(
        price_monthly_usd=35.0,
        price_yearly_usd=350.0,
        features=["15 apps", "200GB storage", "SSO", "API access", "Priority support"],
    ),
    SubscriptionTier.PROFESSIONAL: PricingPlan(
        price_monthly_usd=50.0,
        price_yearly_usd=500.0,
        features=["All apps", "500GB storage", "SSO", "API access", "Phone support"],
    ),
    SubscriptionTier.FAMILY: PricingPlan(
        price_monthly_usd=45.0,
        price_yearly_usd=450.0,
        features=["All apps", "500GB storage", "5 users", "Family sharing"],
    ),
    SubscriptionTier.SMALL_BUSINESS: PricingPlan(
        price_monthly_usd=99.0,
        price_yearly_usd=990.0,
        features=["All apps", "1TB storage", "10 users", "Business tools"],
    ),
    SubscriptionTier.ENTERPRISE: PricingPlan(
        price_monthly_usd=249.0,
        price_yearly_usd=2490.0,
        features=["All apps", "Unlimited storage", "Unlimited users", "Dedicated support"],
    ),
}


@dataclass
class CheckoutMetadata:
    """Metadata attached to Stripe checkout session."""
    bundle: str
    tier: str  # t1, t2, t3
    provider_id: str
    region: str
    datacenter_id: str
    beacon_name: str = ""  # Subdomain (e.g., "mybeacon" -> mybeacon.wopr.systems)
    custom_domain: Optional[str] = None
    customer_email: str = ""
    customer_name: str = ""
    referral_code: Optional[str] = None
    billing_period: str = "monthly"  # monthly or yearly
    additional_users: str = ""  # JSON array for family/business bundles

    def to_dict(self) -> Dict[str, str]:
        """Convert to Stripe-compatible metadata dict (all strings)."""
        return {
            "wopr_bundle": self.bundle,
            "wopr_tier": self.tier,
            "wopr_provider": self.provider_id,
            "wopr_region": self.region,
            "wopr_datacenter": self.datacenter_id,
            "wopr_beacon_name": self.beacon_name,
            "wopr_custom_domain": self.custom_domain or "",
            "wopr_customer_name": self.customer_name,
            "wopr_referral": self.referral_code or "",
            "wopr_billing_period": self.billing_period,
            "wopr_additional_users": self.additional_users,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, str]) -> "CheckoutMetadata":
        """Create from Stripe metadata dict."""
        return cls(
            bundle=data.get("wopr_bundle", ""),
            tier=data.get("wopr_tier", "t1"),
            provider_id=data.get("wopr_provider", ""),
            region=data.get("wopr_region", ""),
            datacenter_id=data.get("wopr_datacenter", ""),
            beacon_name=data.get("wopr_beacon_name", ""),
            custom_domain=data.get("wopr_custom_domain") or None,
            customer_name=data.get("wopr_customer_name", ""),
            referral_code=data.get("wopr_referral") or None,
            billing_period=data.get("wopr_billing_period", "monthly"),
            additional_users=data.get("wopr_additional_users", ""),
        )


class WOPRBilling:
    """
    Stripe billing integration for WOPR.

    Handles:
    - Creating checkout sessions
    - Processing webhooks
    - Managing subscriptions

    Supports per-beacon Stripe mode (test/live) while sharing the same
    WOPR Stripe account for all transactions.
    """

    def __init__(
        self,
        test_secret_key: str,
        live_secret_key: str,
        test_webhook_secret: str,
        live_webhook_secret: str,
        success_url: str,
        cancel_url: str,
        default_mode: str = "test",
    ):
        """
        Initialize billing with both test and live keys.

        Args:
            test_secret_key: Stripe test secret API key
            live_secret_key: Stripe live secret API key
            test_webhook_secret: Test webhook signing secret
            live_webhook_secret: Live webhook signing secret
            success_url: URL to redirect after successful payment
            cancel_url: URL to redirect if payment cancelled
            default_mode: Default mode if not specified ("test" or "live")
        """
        if not STRIPE_AVAILABLE:
            raise ImportError("stripe package not installed. Run: pip install stripe")

        self.test_secret_key = test_secret_key
        self.live_secret_key = live_secret_key
        self.test_webhook_secret = test_webhook_secret
        self.live_webhook_secret = live_webhook_secret
        self.success_url = success_url
        self.cancel_url = cancel_url
        self.default_mode = default_mode

        # Set default API key (can be overridden per-request)
        stripe.api_key = self.get_secret_key(default_mode)

    def get_secret_key(self, mode: str = None) -> str:
        """Get the Stripe secret key for the specified mode."""
        effective_mode = mode or self.default_mode
        return self.live_secret_key if effective_mode == "live" else self.test_secret_key

    def get_webhook_secret(self, mode: str = None) -> str:
        """Get the webhook secret for the specified mode."""
        effective_mode = mode or self.default_mode
        return self.live_webhook_secret if effective_mode == "live" else self.test_webhook_secret

    def create_checkout_session(
        self,
        email: str,
        name: str,
        bundle: str,
        tier: str,
        beacon_name: str,
        provider_id: str,
        region: str,
        datacenter_id: str,
        billing_period: str = "monthly",
        custom_domain: Optional[str] = None,
        referral_code: Optional[str] = None,
        additional_users: Optional[List[str]] = None,
        stripe_mode: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Create a Stripe Checkout Session for a WOPR subscription.

        Args:
            email: Customer email
            name: Customer name
            bundle: WOPR bundle ID (e.g., "starter", "developer", "meeting_room")
            tier: Storage tier (t1, t2, t3)
            beacon_name: Subdomain for the beacon
            provider_id: VPS provider ID
            region: Geographic region
            datacenter_id: Specific datacenter
            billing_period: "monthly" or "yearly"
            custom_domain: Optional custom domain
            referral_code: Optional referral code
            additional_users: List of additional user emails (for family/business)
            stripe_mode: Override Stripe mode ("test" or "live") for this session

        Returns:
            Dict with session_id and checkout_url
        """
        # Determine effective Stripe mode
        effective_mode = stripe_mode or self.default_mode

        # Use the appropriate API key for this request
        api_key = self.get_secret_key(effective_mode)

        # Validate bundle and tier
        if not is_valid_bundle(bundle):
            raise ValueError(f"Unknown bundle: {bundle}")
        if not is_valid_tier(tier):
            raise ValueError(f"Invalid tier: {tier}. Must be t1, t2, or t3")

        # Get Stripe price ID for the effective mode
        price_id = get_price_id(bundle, tier, billing_period, mode=effective_mode)
        if not price_id:
            raise ValueError(
                f"No Stripe price configured for {bundle}/{tier}/{billing_period}. "
                "Run stripe-setup.ps1 to create products."
            )

        # Get price for display
        price_cents = get_price_cents(bundle, tier)
        bundle_info = get_bundle_info(bundle) or {}

        # Build metadata
        metadata = CheckoutMetadata(
            bundle=bundle,
            tier=tier,
            provider_id=provider_id,
            region=region,
            datacenter_id=datacenter_id,
            beacon_name=beacon_name,
            custom_domain=custom_domain,
            customer_email=email,
            customer_name=name,
            referral_code=referral_code,
            billing_period=billing_period,
            additional_users=json.dumps(additional_users or []),
        )

        # Find or create Stripe customer (required for Accounts V2 test mode)
        # Use api_key parameter to support per-beacon mode switching
        existing = stripe.Customer.list(email=email, limit=1, api_key=api_key)
        if existing.data:
            customer_id = existing.data[0].id
        else:
            customer = stripe.Customer.create(email=email, name=name, api_key=api_key)
            customer_id = customer.id

        # Create Stripe checkout session with per-beacon API key
        session = stripe.checkout.Session.create(
            api_key=api_key,
            mode="subscription",
            payment_method_types=["card"],
            customer=customer_id,
            line_items=[
                {
                    "price": price_id,
                    "quantity": 1,
                }
            ],
            success_url=f"{self.success_url}?session_id={{CHECKOUT_SESSION_ID}}",
            cancel_url=self.cancel_url,
            metadata=metadata.to_dict(),
            subscription_data={
                "metadata": metadata.to_dict(),
            },
            # Collect billing address for tax purposes
            billing_address_collection="required",
            # Allow promotion codes
            allow_promotion_codes=True,
        )

        return {
            "session_id": session.id,
            "checkout_url": session.url,
            "bundle": bundle,
            "bundle_name": bundle_info.get("name", bundle),
            "tier": tier,
            "price_monthly_cents": price_cents,
            "price_display": get_price_display(bundle, tier),
            "billing_period": billing_period,
            "stripe_mode": effective_mode,
        }

    def verify_webhook_signature(
        self,
        payload: bytes,
        signature: str,
        stripe_mode: Optional[str] = None,
    ) -> stripe.Event:
        """
        Verify webhook signature and return event.

        Args:
            payload: Raw request body
            signature: Stripe-Signature header
            stripe_mode: Stripe mode to use for webhook secret ("test" or "live")

        Returns:
            Verified Stripe Event

        Raises:
            ValueError: If signature verification fails
        """
        webhook_secret = self.get_webhook_secret(stripe_mode)
        try:
            event = stripe.Webhook.construct_event(
                payload,
                signature,
                webhook_secret,
            )
            return event
        except stripe.error.SignatureVerificationError as e:
            raise ValueError(f"Invalid webhook signature: {e}")

    def handle_checkout_completed(
        self,
        session: stripe.checkout.Session,
    ) -> Dict[str, Any]:
        """
        Handle checkout.session.completed event.

        This is called when payment succeeds and subscription is created.

        Args:
            session: Stripe Checkout Session object

        Returns:
            Dict with provisioning details
        """
        # Extract metadata
        metadata = CheckoutMetadata.from_dict(session.metadata or {})

        # Get customer info
        customer_id = session.customer
        subscription_id = session.subscription
        customer_email = session.customer_details.email if session.customer_details else ""
        customer_name = session.customer_details.name if session.customer_details else metadata.customer_name

        # Parse additional users
        try:
            additional_users = json.loads(metadata.additional_users) if metadata.additional_users else []
        except json.JSONDecodeError:
            additional_users = []

        return {
            "event": "checkout_completed",
            "customer_id": customer_id,
            "subscription_id": subscription_id,
            "customer_email": customer_email,
            "customer_name": customer_name,
            "bundle": metadata.bundle,
            "tier": metadata.tier,
            "beacon_name": metadata.beacon_name,
            "provider_id": metadata.provider_id,
            "region": metadata.region,
            "datacenter_id": metadata.datacenter_id,
            "custom_domain": metadata.custom_domain,
            "billing_period": metadata.billing_period,
            "additional_users": additional_users,
            "ready_to_provision": True,
        }

    def handle_subscription_updated(
        self,
        subscription: stripe.Subscription,
    ) -> Dict[str, Any]:
        """Handle subscription updates (upgrades, downgrades)."""
        return {
            "event": "subscription_updated",
            "subscription_id": subscription.id,
            "status": subscription.status,
            "current_period_end": subscription.current_period_end,
        }

    def handle_subscription_deleted(
        self,
        subscription: stripe.Subscription,
    ) -> Dict[str, Any]:
        """Handle subscription cancellation."""
        return {
            "event": "subscription_deleted",
            "subscription_id": subscription.id,
            "cancel_at": subscription.canceled_at,
            # Trigger cleanup workflow
            "action": "schedule_instance_deletion",
        }

    def handle_payment_failed(
        self,
        invoice: stripe.Invoice,
    ) -> Dict[str, Any]:
        """Handle failed payment."""
        return {
            "event": "payment_failed",
            "invoice_id": invoice.id,
            "subscription_id": invoice.subscription,
            "customer_id": invoice.customer,
            "amount_due": invoice.amount_due,
            # Trigger notification
            "action": "notify_payment_failed",
        }

    def process_webhook(
        self,
        payload: bytes,
        signature: str,
        stripe_mode: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Process incoming Stripe webhook.

        Args:
            payload: Raw request body
            signature: Stripe-Signature header
            stripe_mode: Stripe mode for webhook secret ("test" or "live")

        Returns:
            Dict with event handling result
        """
        event = self.verify_webhook_signature(payload, signature, stripe_mode)

        handlers = {
            "checkout.session.completed": lambda e: self.handle_checkout_completed(e.data.object),
            "customer.subscription.updated": lambda e: self.handle_subscription_updated(e.data.object),
            "customer.subscription.deleted": lambda e: self.handle_subscription_deleted(e.data.object),
            "customer.subscription.trial_will_end": lambda e: self.handle_trial_will_end(e.data.object),
            "invoice.payment_failed": lambda e: self.handle_payment_failed(e.data.object),
        }

        handler = handlers.get(event.type)
        if handler:
            result = handler(event)
            result["event_id"] = event.id
            result["event_type"] = event.type
            return result

        return {
            "event_id": event.id,
            "event_type": event.type,
            "handled": False,
        }

    def get_subscription(self, subscription_id: str) -> stripe.Subscription:
        """Get subscription details."""
        return stripe.Subscription.retrieve(subscription_id)

    def cancel_subscription(
        self,
        subscription_id: str,
        at_period_end: bool = True,
    ) -> stripe.Subscription:
        """
        Cancel a subscription.

        Args:
            subscription_id: Stripe subscription ID
            at_period_end: If True, cancel at end of billing period

        Returns:
            Updated subscription
        """
        return stripe.Subscription.modify(
            subscription_id,
            cancel_at_period_end=at_period_end,
        )

    # ============================================
    # TRIAL MANAGEMENT
    # ============================================

    def create_trial_subscription(
        self,
        customer_id: str,
        trial_price_id: str,
        trial_days: int,
        metadata: Dict[str, str],
    ) -> Dict[str, Any]:
        """
        Create a trial subscription for add-on modules.

        This creates a subscription with a trial period that:
        - Doesn't require payment method upfront
        - Converts to paid after trial ends
        - Can be cancelled anytime during trial

        Args:
            customer_id: Stripe customer ID
            trial_price_id: Price ID for the trial (post-trial billing)
            trial_days: Number of trial days (typically 90)
            metadata: WOPR metadata (trial_id, modules, etc.)

        Returns:
            Dict with subscription details
        """
        subscription = stripe.Subscription.create(
            customer=customer_id,
            items=[{"price": trial_price_id}],
            trial_period_days=trial_days,
            # Allow trial without payment method
            payment_behavior="default_incomplete",
            payment_settings={
                "save_default_payment_method": "on_subscription",
            },
            metadata=metadata,
            expand=["latest_invoice"],
        )

        return {
            "subscription_id": subscription.id,
            "status": subscription.status,
            "trial_start": subscription.trial_start,
            "trial_end": subscription.trial_end,
            "current_period_end": subscription.current_period_end,
        }

    def get_customer_trials(self, customer_id: str) -> List[Dict[str, Any]]:
        """
        Get all trial subscriptions for a customer.

        Returns:
            List of trial subscription details
        """
        subscriptions = stripe.Subscription.list(
            customer=customer_id,
            status="trialing",
        )

        trials = []
        for sub in subscriptions.data:
            # Check if it's a WOPR trial
            if sub.metadata.get("wopr_trial_id"):
                trials.append({
                    "subscription_id": sub.id,
                    "trial_id": sub.metadata.get("wopr_trial_id"),
                    "trial_name": sub.metadata.get("wopr_trial_name"),
                    "modules": sub.metadata.get("wopr_modules", "").split(","),
                    "trial_end": sub.trial_end,
                    "days_remaining": max(0, (sub.trial_end - int(datetime.now().timestamp())) // 86400),
                })

        return trials

    def convert_trial_to_paid(
        self,
        subscription_id: str,
    ) -> Dict[str, Any]:
        """
        Convert a trial subscription to paid immediately.

        Called when user upgrades their bundle to include trial features.

        Args:
            subscription_id: Trial subscription ID

        Returns:
            Updated subscription details
        """
        subscription = stripe.Subscription.modify(
            subscription_id,
            trial_end="now",  # End trial immediately
            proration_behavior="always_invoice",
        )

        return {
            "subscription_id": subscription.id,
            "status": subscription.status,
            "converted": True,
        }

    def cancel_trial(self, subscription_id: str) -> Dict[str, Any]:
        """
        Cancel a trial subscription.

        Args:
            subscription_id: Trial subscription ID

        Returns:
            Cancellation confirmation
        """
        subscription = stripe.Subscription.delete(subscription_id)

        return {
            "subscription_id": subscription.id,
            "status": "canceled",
            "message": "Trial cancelled. Your data has been preserved.",
        }

    def handle_trial_will_end(
        self,
        subscription: stripe.Subscription,
    ) -> Dict[str, Any]:
        """
        Handle 'customer.subscription.trial_will_end' webhook.

        Stripe sends this 3 days before trial ends.

        Args:
            subscription: Stripe Subscription object

        Returns:
            Dict with notification details
        """
        metadata = subscription.metadata or {}

        return {
            "event": "trial_will_end",
            "subscription_id": subscription.id,
            "trial_id": metadata.get("wopr_trial_id"),
            "trial_name": metadata.get("wopr_trial_name"),
            "modules": metadata.get("wopr_modules", "").split(","),
            "trial_end": subscription.trial_end,
            "customer_id": subscription.customer,
            "action": "send_upgrade_reminder",
        }


# ============================================
# TRIAL PRICE CONFIGURATION
# ============================================

# These need to be created in Stripe Dashboard
# Each trial price should be set up as:
# - Recurring monthly price
# - Trial period configured in Stripe (or we override via API)

TRIAL_PRICES = {
    "reactor_ai_trial": {
        "price_id": "price_reactor_trial",
        "post_trial_price": 9.99,
        "description": "Reactor AI + DEFCON ONE (90-day trial)",
    },
    "developer_tools_trial": {
        "price_id": "price_devtools_trial",
        "post_trial_price": 14.99,
        "description": "Forgejo + Woodpecker + VS Code (30-day trial)",
    },
    "creator_tools_trial": {
        "price_id": "price_creator_trial",
        "post_trial_price": 9.99,
        "description": "Ghost + Saleor (30-day trial)",
    },
    "collaboration_trial": {
        "price_id": "price_collab_trial",
        "post_trial_price": 14.99,
        "description": "Matrix + Jitsi + Collabora (14-day trial)",
    },
}


# ============================================
# WEBHOOK HANDLER (Flask/FastAPI Example)
# ============================================

def create_webhook_handler(billing: WOPRBilling, provisioner):
    """
    Create a webhook handler function.

    This returns a function that can be used as a route handler
    in Flask, FastAPI, or other frameworks.

    Args:
        billing: WOPRBilling instance
        provisioner: WOPRProvisioner instance for triggering deployments

    Returns:
        Handler function
    """
    async def handle_stripe_webhook(request):
        """
        Webhook endpoint for Stripe events.

        POST /webhooks/stripe
        """
        payload = await request.body()
        signature = request.headers.get("Stripe-Signature")

        try:
            result = billing.process_webhook(payload, signature)

            # Trigger provisioning if payment completed
            if result.get("ready_to_provision"):
                # This would be async in production
                provision_result = provisioner.provision_for_bundle(
                    bundle=result["bundle"],
                    domain=f"{result['customer_id']}.wopr.systems",
                    customer_id=result["customer_id"],
                    provider_id=result["provider_id"],
                )

                result["provision_result"] = {
                    "success": provision_result.success,
                    "instance_ip": provision_result.instance.ip_address if provision_result.instance else None,
                }

            return {"status": "ok", "result": result}

        except ValueError as e:
            return {"status": "error", "message": str(e)}, 400

    return handle_stripe_webhook
